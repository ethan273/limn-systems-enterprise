/**
 * Flipbooks tRPC Router
 *
 * Provides type-safe API endpoints for flipbook operations.
 *
 * SCHEMA: Uses flipbook.* tables (isolated from public schema)
 */

import { z } from "zod";
import { createTRPCRouter, protectedProcedure } from "@/server/api/trpc/init";
import { TRPCError } from "@trpc/server";
import {
  validateTOCStructure,
  createEmptyTOC,
  exportTOCToCSV,
  importTOCFromCSV,
} from "@/lib/flipbooks/toc-extractor";
import type { TOCData, TOCItem } from "@/types/flipbook-navigation";
import { TOC_VALIDATION } from "@/types/flipbook-navigation";


/**
 * Input validation schemas
 */
const createFlipbookInput = z.object({
  title: z.string().min(1).max(255),
  description: z.string().optional(),
  pdf_source_url: z.string().url().optional(),
});

const updateFlipbookInput = z.object({
  id: z.string().uuid(),
  title: z.string().min(1).max(255).optional(),
  description: z.string().optional(),
  // FIXME: status field is Unsupported("flipbook_status") in Prisma schema - cannot be used
  // status: z.enum(["DRAFT", "PUBLISHED", "ARCHIVED"]).optional(),
});

const getFlipbookInput = z.object({
  id: z.string().uuid(),
});

const listFlipbooksInput = z.object({
  limit: z.number().min(1).max(100).default(20),
  cursor: z.string().uuid().optional(),
  // FIXME: status field is Unsupported("flipbook_status") in Prisma schema - cannot be used
  // status: z.enum(["DRAFT", "PUBLISHED", "ARCHIVED"]).optional(),
  search: z.string().optional(),
});

/**
 * TOC validation schemas
 */
const tocItemSchema: z.ZodType<TOCItem> = z.lazy(() =>
  z.object({
    id: z.string(),
    title: z.string().min(TOC_VALIDATION.TITLE_MIN_LENGTH).max(TOC_VALIDATION.TITLE_MAX_LENGTH),
    pageNumber: z.number().int().min(TOC_VALIDATION.PAGE_MIN).max(TOC_VALIDATION.PAGE_MAX),
    level: z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4)]),
    sortOrder: z.number(),
    icon: z.string().max(TOC_VALIDATION.ICON_MAX_LENGTH).optional(),
    children: z.array(tocItemSchema),
    metadata: z.object({
      pageCount: z.number().optional(),
      lastModified: z.string().optional(),
      custom: z.record(z.unknown()).optional(),
    }).optional(),
  })
);

const tocDataSchema: z.ZodType<TOCData> = z.object({
  items: z.array(tocItemSchema),
  autoGenerated: z.boolean(),
  lastModified: z.string(),
  version: z.string(),
});

const generateTOCInput = z.object({
  flipbookId: z.string().uuid(),
  tocData: tocDataSchema,
  itemCount: z.number(),
  warnings: z.array(z.string()).optional(),
});

const updateTOCInput = z.object({
  flipbookId: z.string().uuid(),
  tocData: tocDataSchema,
});

const getTOCInput = z.object({
  flipbookId: z.string().uuid(),
});

const deleteTOCInput = z.object({
  flipbookId: z.string().uuid(),
});

const importTOCInput = z.object({
  flipbookId: z.string().uuid(),
  csv: z.string(),
});

const exportTOCInput = z.object({
  flipbookId: z.string().uuid(),
});

/**
 * Flipbooks Router
 */
export const flipbooksRouter = createTRPCRouter({
  /**
   * Get all flipbooks for current user
   */
  list: protectedProcedure
    .input(listFlipbooksInput)
    .query(async ({ ctx, input }) => {
      try {
        const { limit, cursor, search } = input;
        // FIXME: status removed - Unsupported type in Prisma
        // const { limit, cursor, status, search } = input;

        console.log('[FLIPBOOKS] Starting list query', { userId: ctx.session.user.id, limit, search });

        // Get user profile to check if super_admin
        const userProfile = await ctx.db.user_profiles.findUnique({
          where: { id: ctx.session.user.id },
          select: { user_type: true },
        });

        console.log('[FLIPBOOKS] User profile fetched', { userType: userProfile?.user_type });

        const isSuperAdmin = userProfile?.user_type === 'super_admin';

        // Build where clause
        // Super admins can see all flipbooks, regular users only see their own
        const where: any = isSuperAdmin ? {} : {
          created_by_id: ctx.session.user.id,
        };

        // FIXME: status filter removed - Unsupported type in Prisma
        // if (status) {
        //   where.status = status;
        // }

        // Case-insensitive search on title and description
        if (search) {
          where.OR = [
            { title: { contains: search, mode: 'insensitive' } },
            { description: { contains: search, mode: 'insensitive' } },
          ];
        }

        if (cursor) {
          where.id = { lt: cursor };
        }

        console.log('[FLIPBOOKS] Where clause built', { where });

        // Query flipbooks
        const flipbooks = await ctx.db.flipbooks.findMany({
          where,
          take: limit,
          orderBy: { created_at: "desc" },
          include: {
            user_profiles: {
              select: {
                id: true,
                full_name: true,
                email: true,
              },
            },
            flipbook_pages: {
              select: {
                id: true,
                page_number: true,
              },
              orderBy: { page_number: "asc" },
            },
          },
        });

        console.log('[FLIPBOOKS] Query completed', { count: flipbooks.length });

        return {
          flipbooks,
          nextCursor: flipbooks.length === limit ? flipbooks[flipbooks.length - 1]?.id : undefined,
        };
      } catch (error) {
        console.error('[FLIPBOOKS] Error in list query:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to fetch flipbooks',
          cause: error,
        });
      }
    }),

  /**
   * Get single flipbook by ID
   */
  get: protectedProcedure
    .input(getFlipbookInput)
    .query(async ({ ctx, input }) => {
      console.log("[tRPC Get Flipbook] Querying for ID:", input.id);

      // CRITICAL FIX: Cannot use include at top level because flipbooks.status is Unsupported
      // Using include causes Prisma to auto-select ALL flipbooks fields including Unsupported
      // status field, which causes silent failure (returns empty flipbook_pages array)
      //
      // SOLUTION: Query in two steps:
      // 1. First get the flipbook with explicit select (excluding Unsupported fields)
      // 2. Then include relations separately
      //
      // This avoids the "column flipbooks.user_profiles does not exist" error that occurs
      // when mixing select and include in a single query with Unsupported fields
      const flipbookBase = await ctx.db.flipbooks.findUnique({
        where: { id: input.id },
        select: {
          // Explicit select for flipbooks table fields (excluding Unsupported status)
          id: true,
          title: true,
          description: true,
          // status: true, // CRITICAL: Unsupported type - cannot select
          created_by_id: true,
          cover_image_url: true,
          thumbnail_url: true,
          pdf_source_url: true,
          page_count: true,
          view_count: true,
          published_at: true,
          created_at: true,
          updated_at: true,
          settings: true,
          branding: true,
          toc_data: true,
          toc_auto_generated: true,
          toc_last_updated: true,
          navigation_settings: true,
        },
      });

      if (!flipbookBase) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      // Fetch relations separately
      // CRITICAL: Cannot use nested relations with explicit select due to Prisma Unsupported field limitations
      const [creator, pages] = await Promise.all([
        ctx.db.user_profiles.findUnique({
          where: { id: flipbookBase.created_by_id },
          select: {
            id: true,
            full_name: true,
            email: true,
            avatar_url: true,
          },
        }),
        ctx.db.flipbook_pages.findMany({
          where: { flipbook_id: input.id },
          orderBy: { page_number: "asc" },
          select: {
            id: true,
            flipbook_id: true,
            page_number: true,
            image_url: true,
            thumbnail_url: true,
            // page_type: true, // CRITICAL: Unsupported type - cannot select
            text_content: true,
            seo_title: true,
            seo_description: true,
            layout_data: true,
            created_at: true,
            updated_at: true,
            thumbnail_small_url: true,
            thumbnail_generated_at: true,
          },
        }),
      ]);

      // Fetch hotspots for all pages (now that we have page IDs)
      const pageIds = pages.map(p => p.id);
      const allHotspots = pageIds.length > 0
        ? await ctx.db.hotspots.findMany({
            where: {
              page_id: { in: pageIds }
            },
            select: {
              id: true,
              page_id: true,
              // hotspot_type: true, // CRITICAL: Unsupported type - cannot select
              x_position: true,
              y_position: true,
              width: true,
              height: true,
              target_url: true,
              target_page: true,
              target_product_id: true,
              popup_content: true,
              form_config: true,
              style_config: true,
              click_count: true,
              created_at: true,
              updated_at: true,
              products: {
                select: {
                  id: true,
                  name: true,
                  sku: true,
                },
              },
            },
          })
        : [];

      // Attach hotspots to their respective pages
      const pagesWithHotspots: (typeof pages[0] & { hotspots: typeof allHotspots })[] = pages.map(page => ({
        ...page,
        hotspots: allHotspots.filter(h => h.page_id === page.id),
      }));

      // Combine results
      const flipbook = {
        ...flipbookBase,
        user_profiles: creator,
        flipbook_pages: pagesWithHotspots,
        flipbook_versions: [], // Empty array - not needed for this query
      } as typeof flipbookBase & {
        user_profiles: typeof creator;
        flipbook_pages: typeof pagesWithHotspots;
        flipbook_versions: any[];
      };

      console.log("[tRPC Get Flipbook] Result:", {
        id: flipbook?.id,
        pageCount: flipbook?.page_count,
        pagesFound: flipbook?.flipbook_pages?.length || 0,
      });

      // Check permissions - only creator can view
      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view this flipbook",
        });
      }

      // Increment view count
      // TEMP: Disabled due to Prisma increment issue
      // await ctx.db.flipbooks.update({
      //   where: { id: input.id },
      //   data: { view_count: { increment: 1 } },
      // });

      return flipbook;
    }),

  /**
   * Create new flipbook
   */
  create: protectedProcedure
    .input(createFlipbookInput)
    .mutation(async ({ ctx, input }) => {
      try {
        console.log("Creating flipbook with data:", {
          title: input.title,
          description: input.description,
          created_by_id: ctx.session.user.id,
          pdf_source_url: input.pdf_source_url,
          // FIXME: status field removed - Unsupported type in Prisma
          // status: "DRAFT",
        });

        const flipbook = await ctx.db.flipbooks.create({
          data: {
            title: input.title,
            description: input.description,
            created_by_id: ctx.session.user.id,
            pdf_source_url: input.pdf_source_url,
            // FIXME: status field removed - Unsupported type in Prisma, cannot be set
            // status: "DRAFT",
          },
          include: {
            user_profiles: {
              select: {
                id: true,
                full_name: true,
                email: true,
              },
            },
          },
        });

        console.log("Flipbook created successfully:", flipbook.id);
        return flipbook;
      } catch (error: any) {
        console.error("Failed to create flipbook:", error);
        console.error("Error code:", error.code);
        console.error("Error message:", error.message);
        console.error("Error meta:", error.meta);
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: error.message || "Failed to create flipbook",
          cause: error,
        });
      }
    }),

  /**
   * Update existing flipbook
   */
  update: protectedProcedure
    .input(updateFlipbookInput)
    .mutation(async ({ ctx, input }) => {
      const { id, ...data } = input;

      // Check if flipbook exists and user has permission
      // NOTE: status field is Unsupported type in Prisma, cannot be selected
      const existing = await ctx.db.flipbooks.findUnique({
        where: { id },
        select: { created_by_id: true },
      });

      if (!existing) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (existing.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to update this flipbook",
        });
      }

      // FIXME: Unsupported type - cannot use status field for published_at logic
      // Update published_at if status changes to PUBLISHED
      // NOTE: Cannot check existing.status or data.status (Unsupported type)
      // const updateData: any = { ...data };
      // if (data.status === "PUBLISHED") {
      //   updateData.published_at = new Date();
      // }

      const flipbook = await ctx.db.flipbooks.update({
        where: { id },
        data,
        include: {
          user_profiles: {
            select: {
              id: true,
              full_name: true,
              email: true,
            },
          },
        },
      });

      return flipbook;
    }),

  /**
   * Delete flipbook
   */
  delete: protectedProcedure
    .input(getFlipbookInput)
    .mutation(async ({ ctx, input }) => {
      // Check if flipbook exists and user has permission
      const existing = await ctx.db.flipbooks.findUnique({
        where: { id: input.id },
        select: { created_by_id: true },
      });

      if (!existing) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (existing.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to delete this flipbook",
        });
      }

      // Delete flipbook (cascade will delete related pages, hotspots, versions, analytics)
      await ctx.db.flipbooks.delete({
        where: { id: input.id },
      });

      return { success: true };
    }),

  /**
   * Get analytics for flipbook
   */
  getAnalytics: protectedProcedure
    .input(getFlipbookInput)
    .query(async ({ ctx, input }) => {
      // Check if flipbook exists and user has permission
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.id },
        select: {
          created_by_id: true,
          view_count: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view analytics for this flipbook",
        });
      }

      // Aggregate analytics events
      const events = await ctx.db.analytics_events.findMany({
        where: { flipbook_id: input.id },
      });

      const views = events.filter(e => e.event_type === "VIEW").length;
      const pageTurns = events.filter(e => e.event_type === "PAGE_TURN").length;
      const hotspotClicks = events.filter(e => e.event_type === "HOTSPOT_CLICK").length;

      // Calculate average time spent from metadata
      const sessions = events.filter(e => e.event_type === "VIEW" && (e.metadata as any)?.session_duration);
      const totalTime = sessions.reduce((sum, e) => sum + ((e.metadata as any)?.session_duration || 0), 0);
      const avgTimeSpent = sessions.length > 0 ? totalTime / sessions.length : 0;

      return {
        views,
        pageTurns,
        hotspotClicks,
        avgTimeSpent: Math.round(avgTimeSpent),
        totalViews: flipbook.view_count || 0,
      };
    }),

  // ========================================
  // PAGE MANAGEMENT ENDPOINTS
  // ========================================

  /**
   * Delete a page from flipbook
   */
  deletePage: protectedProcedure
    .input(z.object({ pageId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // Get page with flipbook info for permission check
      const page = await ctx.db.flipbook_pages.findUnique({
        where: { id: input.pageId },
        include: { flipbooks: { select: { created_by_id: true } } },
      });

      if (!page) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Page not found",
        });
      }

      if (page.flipbooks.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to delete this page",
        });
      }

      await ctx.db.flipbook_pages.delete({
        where: { id: input.pageId },
      });

      return { success: true };
    }),

  /**
   * Reorder pages
   */
  reorderPages: protectedProcedure
    .input(z.object({
      flipbookId: z.string().uuid(),
      pageIds: z.array(z.string().uuid()),
    }))
    .mutation(async ({ ctx, input }) => {
      // Check permissions
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: { created_by_id: true },
      });

      if (!flipbook || flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to reorder pages",
        });
      }

      // Update page numbers based on new order
      for (let i = 0; i < input.pageIds.length; i++) {
        // eslint-disable-next-line security/detect-object-injection
        const pageId = input.pageIds[i]; // Safe: i is bounds-checked loop index
        await ctx.db.flipbook_pages.update({
          where: { id: pageId },
          data: { page_number: i + 1 },
        });
      }

      return { success: true };
    }),

  // ========================================
  // HOTSPOT MANAGEMENT ENDPOINTS
  // ========================================

  /**
   * Create a hotspot on a page
   */
  createHotspot: protectedProcedure
    .input(z.object({
      pageId: z.string().uuid(),
      productId: z.string().uuid(),
      xPercent: z.number().min(0).max(100),
      yPercent: z.number().min(0).max(100),
      width: z.number().min(1).max(100).default(10),
      height: z.number().min(1).max(100).default(10),
      label: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      // Check permissions via page
      const page = await ctx.db.flipbook_pages.findUnique({
        where: { id: input.pageId },
        include: { flipbooks: { select: { created_by_id: true } } },
      });

      if (!page || page.flipbooks.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to add hotspots",
        });
      }

      const hotspot = await ctx.db.hotspots.create({
        data: {
          page_id: input.pageId,
          hotspot_type: "PRODUCT_LINK",
          x_position: input.xPercent,
          y_position: input.yPercent,
          width: input.width,
          height: input.height,
          target_product_id: input.productId,
        },
        include: {
          products: {
            select: {
              id: true,
              name: true,
              sku: true,
              category: true,
              base_price: true,
            },
          },
        },
      });

      return hotspot;
    }),

  /**
   * Update hotspot
   */
  updateHotspot: protectedProcedure
    .input(z.object({
      hotspotId: z.string().uuid(),
      xPercent: z.number().min(0).max(100).optional(),
      yPercent: z.number().min(0).max(100).optional(),
      width: z.number().min(1).max(100).optional(),
      height: z.number().min(1).max(100).optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { hotspotId, xPercent, yPercent, width, height } = input;

      // Check permissions
      // CRITICAL: Must use explicit select (not include) due to Unsupported hotspot_type field
      const hotspot = await ctx.db.hotspots.findUnique({
        where: { id: hotspotId },
        select: {
          id: true,
          flipbook_pages: {
            select: {
              id: true,
              flipbooks: { select: { created_by_id: true } },
            },
          },
        },
      });

      if (!hotspot || hotspot.flipbook_pages.flipbooks.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to update this hotspot",
        });
      }

      // Map input field names to database field names
      const updateData: any = {};
      if (xPercent !== undefined) updateData.x_position = xPercent;
      if (yPercent !== undefined) updateData.y_position = yPercent;
      if (width !== undefined) updateData.width = width;
      if (height !== undefined) updateData.height = height;

      // CRITICAL: Must use explicit select (not include) due to Unsupported hotspot_type field
      const updated = await ctx.db.hotspots.update({
        where: { id: hotspotId },
        data: updateData,
        select: {
          id: true,
          page_id: true,
          // hotspot_type: true, // CRITICAL: Unsupported type - cannot select
          x_position: true,
          y_position: true,
          width: true,
          height: true,
          target_url: true,
          target_page: true,
          target_product_id: true,
          popup_content: true,
          form_config: true,
          style_config: true,
          click_count: true,
          created_at: true,
          updated_at: true,
          products: {
            select: {
              id: true,
              name: true,
              sku: true,
              category: true,
              base_price: true,
            },
          },
        },
      });

      return updated;
    }),

  /**
   * Delete hotspot
   */
  deleteHotspot: protectedProcedure
    .input(z.object({ hotspotId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // Check permissions
      // CRITICAL: Must use explicit select (not include) due to Unsupported hotspot_type field
      const hotspot = await ctx.db.hotspots.findUnique({
        where: { id: input.hotspotId },
        select: {
          id: true,
          flipbook_pages: {
            select: {
              id: true,
              flipbooks: { select: { created_by_id: true } },
            },
          },
        },
      });

      if (!hotspot || hotspot.flipbook_pages.flipbooks.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to delete this hotspot",
        });
      }

      await ctx.db.hotspots.delete({
        where: { id: input.hotspotId },
      });

      return { success: true };
    }),

  // ========================================
  // TABLE OF CONTENTS (TOC) ENDPOINTS
  // ========================================

  /**
   * Save auto-generated TOC from PDF bookmarks
   * Accepts TOC data extracted client-side and saves it to database
   * Note: PDF.js extraction happens in browser to avoid Node.js compatibility issues
   */
  generateTOC: protectedProcedure
    .input(generateTOCInput)
    .mutation(async ({ ctx, input }) => {
      // Check if flipbook exists and user has permission
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to modify this flipbook",
        });
      }

      // Validate structure of provided TOC data
      const validation = validateTOCStructure(input.tocData);
      if (!validation.valid) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: `Invalid TOC structure: ${validation.errors.join(", ")}`,
        });
      }

      // Save to database
      const updated = await ctx.db.flipbooks.update({
        where: { id: input.flipbookId },
        data: {
          toc_data: input.tocData as any,
          toc_auto_generated: true,
          toc_last_updated: new Date(),
        },
        select: {
          id: true,
          toc_data: true,
          toc_auto_generated: true,
          toc_last_updated: true,
        },
      });

      return {
        success: true,
        tocData: updated.toc_data as unknown as TOCData,
        itemCount: input.itemCount,
        warnings: input.warnings,
      };
    }),

  /**
   * Get TOC for a flipbook
   */
  getTOC: protectedProcedure
    .input(getTOCInput)
    .query(async ({ ctx, input }) => {
      // Check if flipbook exists and user has permission
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
          toc_data: true,
          toc_auto_generated: true,
          toc_last_updated: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view this flipbook",
        });
      }

      // Return TOC data or empty structure if none exists
      return {
        tocData: (flipbook.toc_data as unknown as TOCData) || createEmptyTOC(),
        autoGenerated: flipbook.toc_auto_generated || false,
        lastUpdated: flipbook.toc_last_updated?.toISOString() || null,
      };
    }),

  /**
   * Update TOC manually
   * Allows full CRUD operations on TOC structure
   */
  updateTOC: protectedProcedure
    .input(updateTOCInput)
    .mutation(async ({ ctx, input }) => {
      // Check if flipbook exists and user has permission
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to modify this flipbook",
        });
      }

      // Validate TOC structure
      const validation = validateTOCStructure(input.tocData);
      if (!validation.valid) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: `Invalid TOC structure: ${validation.errors.join(", ")}`,
        });
      }

      // Update last modified timestamp
      const tocData: TOCData = {
        ...input.tocData,
        lastModified: new Date().toISOString(),
      };

      // Save to database
      const updated = await ctx.db.flipbooks.update({
        where: { id: input.flipbookId },
        data: {
          toc_data: tocData as any,
          toc_auto_generated: false, // Manual update marks as not auto-generated
          toc_last_updated: new Date(),
        },
        select: {
          id: true,
          toc_data: true,
          toc_auto_generated: true,
          toc_last_updated: true,
        },
      });

      return {
        success: true,
        tocData: updated.toc_data as unknown as TOCData,
        lastUpdated: updated.toc_last_updated?.toISOString(),
      };
    }),

  /**
   * Delete TOC from flipbook
   */
  deleteTOC: protectedProcedure
    .input(deleteTOCInput)
    .mutation(async ({ ctx, input }) => {
      // Check if flipbook exists and user has permission
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to modify this flipbook",
        });
      }

      // Clear TOC data
      await ctx.db.flipbooks.update({
        where: { id: input.flipbookId },
        data: {
          toc_data: null as any,
          toc_auto_generated: false,
          toc_last_updated: null,
        },
      });

      return { success: true };
    }),

  /**
   * Import TOC from CSV
   */
  importTOCFromCSV: protectedProcedure
    .input(importTOCInput)
    .mutation(async ({ ctx, input }) => {
      // Check if flipbook exists and user has permission
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to modify this flipbook",
        });
      }

      // Parse CSV
      let tocData: TOCData;
      try {
        tocData = importTOCFromCSV(input.csv);
      } catch (error) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Invalid CSV format",
        });
      }

      // Validate structure
      const validation = validateTOCStructure(tocData);
      if (!validation.valid) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: `Invalid TOC structure: ${validation.errors.join(", ")}`,
        });
      }

      // Save to database
      const updated = await ctx.db.flipbooks.update({
        where: { id: input.flipbookId },
        data: {
          toc_data: tocData as any,
          toc_auto_generated: false,
          toc_last_updated: new Date(),
        },
        select: {
          id: true,
          toc_data: true,
          toc_last_updated: true,
        },
      });

      return {
        success: true,
        tocData: updated.toc_data as unknown as TOCData,
        itemCount: tocData.items.length,
      };
    }),

  /**
   * Export TOC to CSV
   */
  exportTOCToCSV: protectedProcedure
    .input(exportTOCInput)
    .query(async ({ ctx, input }) => {
      // Check if flipbook exists and user has permission
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
          toc_data: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view this flipbook",
        });
      }

      if (!flipbook.toc_data) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Flipbook does not have a TOC",
        });
      }

      // Export to CSV
      const csv = exportTOCToCSV(flipbook.toc_data as unknown as TOCData);

      return {
        csv,
        filename: `flipbook-${input.flipbookId}-toc.csv`,
      };
    }),

  /**
   * SHARE LINKS
   * Phase 9: Unique Tracking Links
   */

  /**
   * Create a new share link for a flipbook
   */
  createShareLink: protectedProcedure
    .input(
      z.object({
        flipbookId: z.string().uuid(),
        label: z.string().max(255).optional(),
        vanitySlug: z.string().max(100).regex(/^[a-z0-9-]+$/).optional(),
        expiresAt: z.date().optional(),
        settings: z.object({
          theme: z.enum(["light", "dark", "auto"]).optional(),
          startPage: z.number().int().min(1).optional(),
          showControls: z.boolean().optional(),
        }).optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      // Check if flipbook exists and user has permission
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: { id: true, created_by_id: true },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to create share links for this flipbook",
        });
      }

      // Check if vanity slug is already taken
      if (input.vanitySlug) {
        const existing = await ctx.db.flipbook_share_links.findUnique({
          where: { vanity_slug: input.vanitySlug },
        });

        if (existing) {
          throw new TRPCError({
            code: "CONFLICT",
            message: "This vanity slug is already taken",
          });
        }
      }

      // Generate random token (64 characters)
      const token = Array.from({ length: 64 }, () =>
        Math.random().toString(36).charAt(2)
      ).join('');

      // Create share link
      const shareLink = await ctx.db.flipbook_share_links.create({
        data: {
          flipbook_id: input.flipbookId,
          created_by_id: ctx.session.user.id,
          token,
          vanity_slug: input.vanitySlug,
          label: input.label,
          expires_at: input.expiresAt,
          settings: input.settings || {},
        },
        include: {
          flipbooks: {
            select: {
              id: true,
              title: true,
            },
          },
        },
      });

      return shareLink;
    }),

  /**
   * Get all share links for a flipbook
   */
  getShareLinks: protectedProcedure
    .input(z.object({ flipbookId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      // Check permission
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: { created_by_id: true },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view share links for this flipbook",
        });
      }

      const shareLinks = await ctx.db.flipbook_share_links.findMany({
        where: { flipbook_id: input.flipbookId },
        orderBy: { created_at: 'desc' },
      });

      return shareLinks;
    }),

  /**
   * Get a share link by token (public endpoint for viewing)
   */
  getShareLinkByToken: protectedProcedure
    .input(z.object({ token: z.string() }))
    .query(async ({ input, ctx }) => {
      const shareLink = await ctx.db.flipbook_share_links.findUnique({
        where: { token: input.token },
        include: {
          flipbooks: {
            include: {
              flipbook_pages: {
                orderBy: { page_number: 'asc' },
                include: {
                  hotspots: {
                    include: {
                      products: {
                        select: {
                          id: true,
                          name: true,
                          sku: true,
                        },
                      },
                    },
                  },
                },
              },
            },
          },
        },
      });

      if (!shareLink) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Share link not found",
        });
      }

      // Check if expired
      if (shareLink.expires_at && new Date(shareLink.expires_at) < new Date()) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "This share link has expired",
        });
      }

      // Check if active
      if (!shareLink.is_active) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "This share link has been deactivated",
        });
      }

      return shareLink;
    }),

  /**
   * Update a share link
   */
  updateShareLink: protectedProcedure
    .input(
      z.object({
        id: z.string().uuid(),
        label: z.string().max(255).optional(),
        expiresAt: z.date().nullable().optional(),
        isActive: z.boolean().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      // Check permission
      const shareLink = await ctx.db.flipbook_share_links.findUnique({
        where: { id: input.id },
        select: { created_by_id: true },
      });

      if (!shareLink) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Share link not found",
        });
      }

      if (shareLink.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to update this share link",
        });
      }

      const updated = await ctx.db.flipbook_share_links.update({
        where: { id: input.id },
        data: {
          label: input.label,
          expires_at: input.expiresAt === null ? null : input.expiresAt,
          is_active: input.isActive,
          updated_at: new Date(),
        },
      });

      return updated;
    }),

  /**
   * Delete a share link
   */
  deleteShareLink: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // Check permission
      const shareLink = await ctx.db.flipbook_share_links.findUnique({
        where: { id: input.id },
        select: { created_by_id: true },
      });

      if (!shareLink) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Share link not found",
        });
      }

      if (shareLink.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to delete this share link",
        });
      }

      await ctx.db.flipbook_share_links.delete({
        where: { id: input.id },
      });

      return { success: true };
    }),

  /**
   * Track a share link view
   */
  trackShareLinkView: protectedProcedure
    .input(
      z.object({
        token: z.string(),
        viewerIp: z.string().optional(),
        viewerUserAgent: z.string().optional(),
        referrer: z.string().optional(),
        sessionId: z.string().uuid().optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      // Find share link
      const shareLink = await ctx.db.flipbook_share_links.findUnique({
        where: { token: input.token },
      });

      if (!shareLink || !shareLink.is_active) {
        return { success: false };
      }

      // Create view record
      await ctx.db.share_link_views.create({
        data: {
          share_link_id: shareLink.id,
          viewer_ip: input.viewerIp,
          viewer_user_agent: input.viewerUserAgent,
          referrer: input.referrer,
          session_id: input.sessionId,
        },
      });

      // Update view count
      await ctx.db.flipbook_share_links.update({
        where: { id: shareLink.id },
        data: {
          view_count: { increment: 1 },
          last_viewed_at: new Date(),
        },
      });

      return { success: true };
    }),

  /**
   * Get analytics for a flipbook
   * Returns comprehensive analytics including views, share link performance, and engagement metrics
   */
  getFlipbookAnalytics: protectedProcedure
    .input(z.object({
      flipbookId: z.string().uuid(),
      days: z.number().int().min(1).max(365).default(30),
    }))
    .query(async ({ ctx, input }) => {
      // Permission check
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: { created_by_id: true },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view analytics for this flipbook",
        });
      }

      // Get date range
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - input.days);

      // Get share links
      const shareLinks = await ctx.db.flipbook_share_links.findMany({
        where: { flipbook_id: input.flipbookId },
        select: {
          id: true,
          label: true,
          token: true,
          view_count: true,
          unique_view_count: true,
          created_at: true,
        },
      });

      // Get total views from all share links
      const totalViews = shareLinks.reduce((sum, link) => sum + link.view_count, 0);
      const totalUniqueViews = shareLinks.reduce((sum, link) => sum + link.unique_view_count, 0);

      // Get views over time (last N days)
      const viewsByDay = await ctx.db.$queryRaw<Array<{ date: Date; views: bigint }>>`
        SELECT
          DATE(viewed_at) as date,
          COUNT(*) as views
        FROM public.share_link_views
        WHERE share_link_id IN (
          SELECT id FROM public.flipbook_share_links
          WHERE flipbook_id = ${input.flipbookId}::uuid
        )
        AND viewed_at >= ${startDate}
        GROUP BY DATE(viewed_at)
        ORDER BY date ASC
      `;

      // Get top performing share links
      const topShareLinks = [...shareLinks]
        .sort((a, b) => b.view_count - a.view_count)
        .slice(0, 5)
        .map(link => ({
          id: link.id,
          label: link.label || `Link ${link.token.substring(0, 8)}...`,
          views: link.view_count,
          uniqueViews: link.unique_view_count,
          createdAt: link.created_at,
        }));

      // Get referrer breakdown
      const referrers = await ctx.db.$queryRaw<Array<{ referrer: string | null; count: bigint }>>`
        SELECT
          COALESCE(referrer, 'Direct') as referrer,
          COUNT(*) as count
        FROM public.share_link_views
        WHERE share_link_id IN (
          SELECT id FROM public.flipbook_share_links
          WHERE flipbook_id = ${input.flipbookId}::uuid
        )
        AND viewed_at >= ${startDate}
        GROUP BY referrer
        ORDER BY count DESC
        LIMIT 10
      `;

      // Get geographic distribution (country breakdown)
      const geographic = await ctx.db.$queryRaw<Array<{ country: string | null; city: string | null; count: bigint }>>`
        SELECT
          COALESCE(viewer_country, 'Unknown') as country,
          COALESCE(viewer_city, 'Unknown') as city,
          COUNT(*) as count
        FROM public.share_link_views
        WHERE share_link_id IN (
          SELECT id FROM public.flipbook_share_links
          WHERE flipbook_id = ${input.flipbookId}::uuid
        )
        AND viewed_at >= ${startDate}
        GROUP BY viewer_country, viewer_city
        ORDER BY count DESC
        LIMIT 20
      `;

      // Get device breakdown from user agent
      const devices = await ctx.db.$queryRaw<Array<{ device_type: string; count: bigint }>>`
        SELECT
          CASE
            WHEN viewer_user_agent ILIKE '%Mobile%' OR viewer_user_agent ILIKE '%Android%' THEN 'Mobile'
            WHEN viewer_user_agent ILIKE '%Tablet%' OR viewer_user_agent ILIKE '%iPad%' THEN 'Tablet'
            WHEN viewer_user_agent IS NULL THEN 'Unknown'
            ELSE 'Desktop'
          END as device_type,
          COUNT(*) as count
        FROM public.share_link_views
        WHERE share_link_id IN (
          SELECT id FROM public.flipbook_share_links
          WHERE flipbook_id = ${input.flipbookId}::uuid
        )
        AND viewed_at >= ${startDate}
        GROUP BY device_type
        ORDER BY count DESC
      `;

      return {
        totalViews,
        totalUniqueViews,
        shareLinksCount: shareLinks.length,
        viewsByDay: viewsByDay.map(row => ({
          date: row.date,
          views: Number(row.views),
        })),
        topShareLinks,
        topReferrers: referrers.map(row => ({
          referrer: row.referrer || 'Direct',
          count: Number(row.count),
        })),
        geographic: geographic.map(row => ({
          country: row.country || 'Unknown',
          city: row.city || 'Unknown',
          count: Number(row.count),
        })),
        devices: devices.map(row => ({
          deviceType: row.device_type,
          count: Number(row.count),
        })),
      };
    }),

  /**
   * Get analytics for a specific share link
   */
  getShareLinkAnalytics: protectedProcedure
    .input(z.object({
      shareLinkId: z.string().uuid(),
      days: z.number().int().min(1).max(365).default(30),
    }))
    .query(async ({ ctx, input }) => {
      // Permission check
      const shareLink = await ctx.db.flipbook_share_links.findUnique({
        where: { id: input.shareLinkId },
        select: {
          created_by_id: true,
          view_count: true,
          unique_view_count: true,
          last_viewed_at: true,
        },
      });

      if (!shareLink) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Share link not found",
        });
      }

      if (shareLink.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view analytics for this share link",
        });
      }

      // Get date range
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - input.days);

      // Get views over time
      const viewsByDay = await ctx.db.$queryRaw<Array<{ date: Date; views: bigint }>>`
        SELECT
          DATE(viewed_at) as date,
          COUNT(*) as views
        FROM public.share_link_views
        WHERE share_link_id = ${input.shareLinkId}::uuid
        AND viewed_at >= ${startDate}
        GROUP BY DATE(viewed_at)
        ORDER BY date ASC
      `;

      // Get hourly distribution (for heat map)
      const viewsByHour = await ctx.db.$queryRaw<Array<{ hour: number; views: bigint }>>`
        SELECT
          EXTRACT(HOUR FROM viewed_at) as hour,
          COUNT(*) as views
        FROM public.share_link_views
        WHERE share_link_id = ${input.shareLinkId}::uuid
        AND viewed_at >= ${startDate}
        GROUP BY EXTRACT(HOUR FROM viewed_at)
        ORDER BY hour ASC
      `;

      // Get recent views
      const recentViews = await ctx.db.share_link_views.findMany({
        where: {
          share_link_id: input.shareLinkId,
          viewed_at: { gte: startDate },
        },
        select: {
          viewed_at: true,
          viewer_ip: true,
          viewer_user_agent: true,
          referrer: true,
        },
        orderBy: { viewed_at: 'desc' },
        take: 20,
      });

      return {
        totalViews: shareLink.view_count,
        uniqueViews: shareLink.unique_view_count,
        lastViewedAt: shareLink.last_viewed_at,
        viewsByDay: viewsByDay.map(row => ({
          date: row.date,
          views: Number(row.views),
        })),
        viewsByHour: viewsByHour.map(row => ({
          hour: Number(row.hour),
          views: Number(row.views),
        })),
        recentViews,
      };
    }),

  /**
   * Bulk delete flipbooks
   * Deletes multiple flipbooks at once with permission checks
   */
  bulkDelete: protectedProcedure
    .input(z.object({
      ids: z.array(z.string().uuid()).min(1).max(50),
    }))
    .mutation(async ({ ctx, input }) => {
      // Permission check: ensure user owns all flipbooks
      const flipbooks = await ctx.db.flipbooks.findMany({
        where: { id: { in: input.ids } },
        select: { id: true, created_by_id: true },
      });

      const unauthorized = flipbooks.filter(
        f => f.created_by_id !== ctx.session.user.id
      );

      if (unauthorized.length > 0) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: `You do not have permission to delete ${unauthorized.length} of the selected flipbooks`,
        });
      }

      // Bulk delete with cascading (pages, hotspots, share links will cascade)
      const result = await ctx.db.flipbooks.deleteMany({
        where: { id: { in: input.ids } },
      });

      return { deletedCount: result.count };
    }),

  /**
   * Bulk update status
   * Updates status for multiple flipbooks at once with permission checks
   */
  // FIXME: bulkUpdateStatus disabled - status field is Unsupported type in Prisma
  // bulkUpdateStatus: protectedProcedure
  //   .input(z.object({
  //     ids: z.array(z.string().uuid()).min(1).max(50),
  //     status: z.enum(["DRAFT", "PUBLISHED", "ARCHIVED"]),
  //   }))
  //   .mutation(async ({ ctx, input }) => {
  //     // Permission check: ensure user owns all flipbooks
  //     const flipbooks = await ctx.db.flipbooks.findMany({
  //       where: { id: { in: input.ids } },
  //       select: { id: true, created_by_id: true },
  //     });
  //
  //     const unauthorized = flipbooks.filter(
  //       f => f.created_by_id !== ctx.session.user.id
  //     );
  //
  //     if (unauthorized.length > 0) {
  //       throw new TRPCError({
  //         code: "FORBIDDEN",
  //         message: `You do not have permission to update ${unauthorized.length} of the selected flipbooks`,
  //       });
  //     }
  //
  //     // Bulk update status (updateMany not supported by wrapper, using Promise.all with individual updates)
  //     await Promise.all(
  //       input.ids.map((id) =>
  //         ctx.db.flipbooks.update({
  //           where: { id },
  //           data: {
  //             status: input.status,
  //             updated_at: new Date(),
  //           },
  //         })
  //       )
  //     );
  //
  //     return { updatedCount: input.ids.length };
  //   }),

  /**
   * Bulk duplicate flipbooks
   * Creates copies of multiple flipbooks with all pages and hotspots
   */
  bulkDuplicate: protectedProcedure
    .input(z.object({
      ids: z.array(z.string().uuid()).min(1).max(20), // Lower limit for duplicates
    }))
    .mutation(async ({ ctx, input }) => {
      // Permission check: ensure user owns all flipbooks
      const flipbooks = await ctx.db.flipbooks.findMany({
        where: { id: { in: input.ids } },
        include: {
          flipbook_pages: {
            include: {
              hotspots: true,
            },
            orderBy: { page_number: 'asc' },
          },
        },
      });

      const unauthorized = flipbooks.filter(
        f => f.created_by_id !== ctx.session.user.id
      );

      if (unauthorized.length > 0) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: `You do not have permission to duplicate ${unauthorized.length} of the selected flipbooks`,
        });
      }

      // Duplicate each flipbook
      const duplicatedIds: string[] = [];

      for (const flipbook of flipbooks) {
        // Create duplicate flipbook
        const newFlipbook = await ctx.db.flipbooks.create({
          data: {
            title: `${flipbook.title} (Copy)`,
            description: flipbook.description,
            // FIXME: status field removed - Unsupported type in Prisma, cannot be set
            // status: "DRAFT", // Always start as draft
            pdf_source_url: flipbook.pdf_source_url,
            page_count: flipbook.page_count, // Fixed: was total_pages
            created_by_id: ctx.session.user.id,
            // Removed brand_id - field doesn't exist in schema
          },
        });

        duplicatedIds.push(newFlipbook.id);

        // Duplicate pages
        for (const page of flipbook.flipbook_pages) {
          const newPage = await ctx.db.flipbook_pages.create({
            data: {
              flipbook_id: newFlipbook.id,
              page_number: page.page_number,
              image_url: page.image_url,
            },
          });

          // Duplicate hotspots for this page
          // Include all fields to preserve complete hotspot functionality
          if (page.hotspots && page.hotspots.length > 0) {
            await ctx.db.hotspots.createMany({
              data: page.hotspots.map(hotspot => ({
                page_id: newPage.id,
                // NOTE: hotspot_type cannot be set via createMany (Unsupported field)
                // It will use database default
                x_position: hotspot.x_position,
                y_position: hotspot.y_position,
                width: hotspot.width,
                height: hotspot.height,
                target_url: hotspot.target_url,
                target_page: hotspot.target_page,
                target_product_id: hotspot.target_product_id,
                popup_content: hotspot.popup_content,
                form_config: hotspot.form_config,
                style_config: hotspot.style_config,
                click_count: 0, // Reset click count for duplicated hotspot
              })),
            });
          }
        }
      }

      return {
        duplicatedCount: duplicatedIds.length,
        duplicatedIds,
      };
    }),

  /**
   * Get hotspot heat map data
   * Returns hotspots with click counts for visualization
   */
  getHotspotHeatMap: protectedProcedure
    .input(z.object({
      flipbookId: z.string().uuid(),
      pageId: z.string().uuid().optional(),
    }))
    .query(async ({ ctx, input }) => {
      // Permission check
      const flipbook = await ctx.db.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: { created_by_id: true },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view heat map for this flipbook",
        });
      }

      // Get hotspots with click counts
      // CRITICAL: Must use explicit select (not include) due to Unsupported hotspot_type field
      // CRITICAL: Cannot nest relations in select - must fetch separately
      const hotspotsBase = await ctx.db.hotspots.findMany({
        where: {
          flipbook_pages: {
            flipbook_id: input.flipbookId,
            ...(input.pageId ? { id: input.pageId } : {}),
          },
        },
        select: {
          id: true,
          page_id: true,
          // hotspot_type: true, // CRITICAL: Unsupported type - cannot select
          x_position: true,
          y_position: true,
          width: true,
          height: true,
          target_url: true,
          target_page: true,
          target_product_id: true,
          popup_content: true,
          form_config: true,
          style_config: true,
          click_count: true,
          created_at: true,
          updated_at: true,
        },
        orderBy: {
          click_count: 'desc',
        },
      });

      // Fetch related pages separately
      const pageIds = [...new Set(hotspotsBase.map(h => h.page_id))];
      const pages = await ctx.db.flipbook_pages.findMany({
        where: {
          id: { in: pageIds },
        },
        select: {
          id: true,
          page_number: true,
          image_url: true,
        },
      });

      // Fetch related products separately
      const productIds = [...new Set(hotspotsBase.map(h => h.target_product_id).filter((id): id is string => id !== null))];
      const products = productIds.length > 0
        ? await ctx.db.products.findMany({
            where: {
              id: { in: productIds },
            },
            select: {
              id: true,
              name: true,
            },
          })
        : [];

      // Map relations back to hotspots
      const hotspots = hotspotsBase.map(hotspot => ({
        ...hotspot,
        flipbook_pages: pages.find(p => p.id === hotspot.page_id)!,
        products: hotspot.target_product_id
          ? products.find(p => p.id === hotspot.target_product_id)
          : null,
      }));

      // Calculate max clicks for intensity scaling
      const maxClicks = Math.max(...hotspots.map(h => h.click_count), 1);

      // Helper function to determine intensity color based on click count
      const getIntensityColor = (clicks: number): string => {
        if (clicks === 0) return '#E5E7EB'; // Gray - no clicks
        if (clicks <= 10) return '#3B82F6'; // Blue - low
        if (clicks <= 50) return '#10B981'; // Green - medium
        if (clicks <= 100) return '#F59E0B'; // Yellow - high
        if (clicks <= 500) return '#F97316'; // Orange - very high
        return '#EF4444'; // Red - extremely high
      };

      // Calculate intensity (0-1 scale)
      const calculateIntensity = (clicks: number, max: number): number => {
        if (max === 0) return 0;
        return clicks / max;
      };

      return {
        hotspots: hotspots.map(hotspot => ({
          id: hotspot.id,
          pageId: hotspot.page_id,
          pageNumber: hotspot.flipbook_pages.page_number,
          productId: hotspot.target_product_id,
          productName: hotspot.products?.name || 'Unknown Product',
          xPosition: Number(hotspot.x_position),
          yPosition: Number(hotspot.y_position),
          width: Number(hotspot.width),
          height: Number(hotspot.height),
          clickCount: hotspot.click_count,
          intensity: calculateIntensity(hotspot.click_count, maxClicks),
          color: getIntensityColor(hotspot.click_count),
        })),
        maxClicks,
        totalClicks: hotspots.reduce((sum, h) => sum + h.click_count, 0),
      };
    }),
});
