/**
 * Flipbooks tRPC Router
 *
 * Provides type-safe API endpoints for flipbook operations.
 * All endpoints are only available when the flipbooks feature flag is enabled.
 *
 * FEATURE FLAG: Protected by features.flipbooks check
 * SCHEMA: Uses flipbook.* tables (isolated from public schema)
 */

import { z } from "zod";
import { createTRPCRouter, protectedProcedure } from "@/server/api/trpc/init";
import { TRPCError } from "@trpc/server";
import { features } from "@/lib/features";
import { PrismaClient } from "@prisma/client";
import {
  validateTOCStructure,
  createEmptyTOC,
  exportTOCToCSV,
  importTOCFromCSV,
} from "@/lib/flipbooks/toc-extractor";
import type { TOCData, TOCItem } from "@/types/flipbook-navigation";
import { TOC_VALIDATION } from "@/types/flipbook-navigation";

// Prisma client for flipbooks (separate from hybrid db client)
const prisma = new PrismaClient();

/**
 * Input validation schemas
 */
const createFlipbookInput = z.object({
  title: z.string().min(1).max(255),
  description: z.string().optional(),
  pdf_source_url: z.string().url().optional(),
});

const updateFlipbookInput = z.object({
  id: z.string().uuid(),
  title: z.string().min(1).max(255).optional(),
  description: z.string().optional(),
  status: z.enum(["DRAFT", "PUBLISHED", "ARCHIVED"]).optional(),
});

const getFlipbookInput = z.object({
  id: z.string().uuid(),
});

const listFlipbooksInput = z.object({
  limit: z.number().min(1).max(100).default(20),
  cursor: z.string().uuid().optional(),
  status: z.enum(["DRAFT", "PUBLISHED", "ARCHIVED"]).optional(),
  search: z.string().optional(),
});

/**
 * TOC validation schemas
 */
const tocItemSchema: z.ZodType<TOCItem> = z.lazy(() =>
  z.object({
    id: z.string(),
    title: z.string().min(TOC_VALIDATION.TITLE_MIN_LENGTH).max(TOC_VALIDATION.TITLE_MAX_LENGTH),
    pageNumber: z.number().int().min(TOC_VALIDATION.PAGE_MIN).max(TOC_VALIDATION.PAGE_MAX),
    level: z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4)]),
    sortOrder: z.number(),
    icon: z.string().max(TOC_VALIDATION.ICON_MAX_LENGTH).optional(),
    children: z.array(tocItemSchema),
    metadata: z.object({
      pageCount: z.number().optional(),
      lastModified: z.string().optional(),
      custom: z.record(z.unknown()).optional(),
    }).optional(),
  })
);

const tocDataSchema: z.ZodType<TOCData> = z.object({
  items: z.array(tocItemSchema),
  autoGenerated: z.boolean(),
  lastModified: z.string(),
  version: z.string(),
});

const generateTOCInput = z.object({
  flipbookId: z.string().uuid(),
  tocData: tocDataSchema,
  itemCount: z.number(),
  warnings: z.array(z.string()).optional(),
});

const updateTOCInput = z.object({
  flipbookId: z.string().uuid(),
  tocData: tocDataSchema,
});

const getTOCInput = z.object({
  flipbookId: z.string().uuid(),
});

const deleteTOCInput = z.object({
  flipbookId: z.string().uuid(),
});

const importTOCInput = z.object({
  flipbookId: z.string().uuid(),
  csv: z.string(),
});

const exportTOCInput = z.object({
  flipbookId: z.string().uuid(),
});

/**
 * Flipbooks Router
 */
export const flipbooksRouter = createTRPCRouter({
  /**
   * Get all flipbooks for current user
   */
  list: protectedProcedure
    .input(listFlipbooksInput)
    .query(async ({ ctx, input }) => {
      // Feature flag check
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      const { limit, cursor, status, search } = input;

      // Build where clause
      const where: any = {
        created_by_id: ctx.session.user.id,
      };

      if (status) {
        where.status = status;
      }

      if (search) {
        where.OR = [
          { title: { contains: search, mode: 'insensitive' } },
          { description: { contains: search, mode: 'insensitive' } },
        ];
      }

      if (cursor) {
        where.id = { lt: cursor };
      }

      // Query flipbooks
      const flipbooks = await prisma.flipbooks.findMany({
        where,
        take: limit,
        orderBy: { created_at: "desc" },
        include: {
          user_profiles: {
            select: {
              id: true,
              full_name: true,
              email: true,
            },
          },
          flipbook_pages: {
            select: {
              id: true,
              page_number: true,
            },
            orderBy: { page_number: "asc" },
          },
        },
      });

      return {
        flipbooks,
        nextCursor: flipbooks.length === limit ? flipbooks[flipbooks.length - 1]?.id : undefined,
      };
    }),

  /**
   * Get single flipbook by ID
   */
  get: protectedProcedure
    .input(getFlipbookInput)
    .query(async ({ ctx, input }) => {
      // Feature flag check
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      const flipbook = await prisma.flipbooks.findUnique({
        where: { id: input.id },
        include: {
          user_profiles: {
            select: {
              id: true,
              full_name: true,
              email: true,
              avatar_url: true,
            },
          },
          flipbook_pages: {
            orderBy: { page_number: "asc" },
            include: {
              hotspots: {
                include: {
                  products: {
                    select: {
                      id: true,
                      name: true,
                      sku: true,
                    },
                  },
                },
              },
            },
          },
          flipbook_versions: {
            orderBy: { version_number: "desc" },
            take: 5,
          },
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      // Check permissions - only creator can view
      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view this flipbook",
        });
      }

      // Increment view count
      await prisma.flipbooks.update({
        where: { id: input.id },
        data: { view_count: { increment: 1 } },
      });

      return flipbook;
    }),

  /**
   * Create new flipbook
   */
  create: protectedProcedure
    .input(createFlipbookInput)
    .mutation(async ({ ctx, input }) => {
      // Feature flag check
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      try {
        console.log("Creating flipbook with data:", {
          title: input.title,
          description: input.description,
          created_by_id: ctx.session.user.id,
          pdf_source_url: input.pdf_source_url,
          status: "DRAFT",
        });

        const flipbook = await prisma.flipbooks.create({
          data: {
            title: input.title,
            description: input.description,
            created_by_id: ctx.session.user.id,
            pdf_source_url: input.pdf_source_url,
            status: "DRAFT",
          },
          include: {
            user_profiles: {
              select: {
                id: true,
                full_name: true,
                email: true,
              },
            },
          },
        });

        console.log("Flipbook created successfully:", flipbook.id);
        return flipbook;
      } catch (error: any) {
        console.error("Failed to create flipbook:", error);
        console.error("Error code:", error.code);
        console.error("Error message:", error.message);
        console.error("Error meta:", error.meta);
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: error.message || "Failed to create flipbook",
          cause: error,
        });
      }
    }),

  /**
   * Update existing flipbook
   */
  update: protectedProcedure
    .input(updateFlipbookInput)
    .mutation(async ({ ctx, input }) => {
      // Feature flag check
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      const { id, ...data } = input;

      // Check if flipbook exists and user has permission
      const existing = await prisma.flipbooks.findUnique({
        where: { id },
        select: { created_by_id: true, status: true },
      });

      if (!existing) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (existing.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to update this flipbook",
        });
      }

      // Update published_at if status changes to PUBLISHED
      const updateData: any = { ...data };
      if (data.status === "PUBLISHED" && existing.status !== "PUBLISHED") {
        updateData.published_at = new Date();
      }

      const flipbook = await prisma.flipbooks.update({
        where: { id },
        data: updateData,
        include: {
          user_profiles: {
            select: {
              id: true,
              full_name: true,
              email: true,
            },
          },
        },
      });

      return flipbook;
    }),

  /**
   * Delete flipbook
   */
  delete: protectedProcedure
    .input(getFlipbookInput)
    .mutation(async ({ ctx, input }) => {
      // Feature flag check
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Check if flipbook exists and user has permission
      const existing = await prisma.flipbooks.findUnique({
        where: { id: input.id },
        select: { created_by_id: true },
      });

      if (!existing) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (existing.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to delete this flipbook",
        });
      }

      // Delete flipbook (cascade will delete related pages, hotspots, versions, analytics)
      await prisma.flipbooks.delete({
        where: { id: input.id },
      });

      return { success: true };
    }),

  /**
   * Get analytics for flipbook
   */
  getAnalytics: protectedProcedure
    .input(getFlipbookInput)
    .query(async ({ ctx, input }) => {
      // Feature flag check
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Check if flipbook exists and user has permission
      const flipbook = await prisma.flipbooks.findUnique({
        where: { id: input.id },
        select: {
          created_by_id: true,
          view_count: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view analytics for this flipbook",
        });
      }

      // Aggregate analytics events
      const events = await prisma.analytics_events.findMany({
        where: { flipbook_id: input.id },
      });

      const views = events.filter(e => e.event_type === "VIEW").length;
      const pageTurns = events.filter(e => e.event_type === "PAGE_TURN").length;
      const hotspotClicks = events.filter(e => e.event_type === "HOTSPOT_CLICK").length;

      // Calculate average time spent from metadata
      const sessions = events.filter(e => e.event_type === "VIEW" && (e.metadata as any)?.session_duration);
      const totalTime = sessions.reduce((sum, e) => sum + ((e.metadata as any)?.session_duration || 0), 0);
      const avgTimeSpent = sessions.length > 0 ? totalTime / sessions.length : 0;

      return {
        views,
        pageTurns,
        hotspotClicks,
        avgTimeSpent: Math.round(avgTimeSpent),
        totalViews: flipbook.view_count || 0,
      };
    }),

  // ========================================
  // PAGE MANAGEMENT ENDPOINTS
  // ========================================

  /**
   * Delete a page from flipbook
   */
  deletePage: protectedProcedure
    .input(z.object({ pageId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Get page with flipbook info for permission check
      const page = await prisma.flipbook_pages.findUnique({
        where: { id: input.pageId },
        include: { flipbooks: { select: { created_by_id: true } } },
      });

      if (!page) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Page not found",
        });
      }

      if (page.flipbooks.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to delete this page",
        });
      }

      await prisma.flipbook_pages.delete({
        where: { id: input.pageId },
      });

      return { success: true };
    }),

  /**
   * Reorder pages
   */
  reorderPages: protectedProcedure
    .input(z.object({
      flipbookId: z.string().uuid(),
      pageIds: z.array(z.string().uuid()),
    }))
    .mutation(async ({ ctx, input }) => {
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Check permissions
      const flipbook = await prisma.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: { created_by_id: true },
      });

      if (!flipbook || flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to reorder pages",
        });
      }

      // Update page numbers based on new order
      for (let i = 0; i < input.pageIds.length; i++) {
        // eslint-disable-next-line security/detect-object-injection
        const pageId = input.pageIds[i]; // Safe: i is bounds-checked loop index
        await prisma.flipbook_pages.update({
          where: { id: pageId },
          data: { page_number: i + 1 },
        });
      }

      return { success: true };
    }),

  // ========================================
  // HOTSPOT MANAGEMENT ENDPOINTS
  // ========================================

  /**
   * Create a hotspot on a page
   */
  createHotspot: protectedProcedure
    .input(z.object({
      pageId: z.string().uuid(),
      productId: z.string().uuid(),
      xPercent: z.number().min(0).max(100),
      yPercent: z.number().min(0).max(100),
      width: z.number().min(1).max(100).default(10),
      height: z.number().min(1).max(100).default(10),
      label: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Check permissions via page
      const page = await prisma.flipbook_pages.findUnique({
        where: { id: input.pageId },
        include: { flipbooks: { select: { created_by_id: true } } },
      });

      if (!page || page.flipbooks.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to add hotspots",
        });
      }

      const hotspot = await prisma.hotspots.create({
        data: {
          page_id: input.pageId,
          hotspot_type: "PRODUCT_LINK",
          x_position: input.xPercent,
          y_position: input.yPercent,
          width: input.width,
          height: input.height,
          target_product_id: input.productId,
        },
        include: {
          products: {
            select: {
              id: true,
              name: true,
              sku: true,
              category: true,
              base_price: true,
            },
          },
        },
      });

      return hotspot;
    }),

  /**
   * Update hotspot
   */
  updateHotspot: protectedProcedure
    .input(z.object({
      hotspotId: z.string().uuid(),
      xPercent: z.number().min(0).max(100).optional(),
      yPercent: z.number().min(0).max(100).optional(),
      width: z.number().min(1).max(100).optional(),
      height: z.number().min(1).max(100).optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      const { hotspotId, xPercent, yPercent, width, height } = input;

      // Check permissions
      const hotspot = await prisma.hotspots.findUnique({
        where: { id: hotspotId },
        include: {
          flipbook_pages: {
            include: {
              flipbooks: { select: { created_by_id: true } },
            },
          },
        },
      });

      if (!hotspot || hotspot.flipbook_pages.flipbooks.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to update this hotspot",
        });
      }

      // Map input field names to database field names
      const updateData: any = {};
      if (xPercent !== undefined) updateData.x_position = xPercent;
      if (yPercent !== undefined) updateData.y_position = yPercent;
      if (width !== undefined) updateData.width = width;
      if (height !== undefined) updateData.height = height;

      const updated = await prisma.hotspots.update({
        where: { id: hotspotId },
        data: updateData,
        include: {
          products: {
            select: {
              id: true,
              name: true,
              sku: true,
              category: true,
              base_price: true,
            },
          },
        },
      });

      return updated;
    }),

  /**
   * Delete hotspot
   */
  deleteHotspot: protectedProcedure
    .input(z.object({ hotspotId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Check permissions
      const hotspot = await prisma.hotspots.findUnique({
        where: { id: input.hotspotId },
        include: {
          flipbook_pages: {
            include: {
              flipbooks: { select: { created_by_id: true } },
            },
          },
        },
      });

      if (!hotspot || hotspot.flipbook_pages.flipbooks.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to delete this hotspot",
        });
      }

      await prisma.hotspots.delete({
        where: { id: input.hotspotId },
      });

      return { success: true };
    }),

  // ========================================
  // TABLE OF CONTENTS (TOC) ENDPOINTS
  // ========================================

  /**
   * Save auto-generated TOC from PDF bookmarks
   * Accepts TOC data extracted client-side and saves it to database
   * Note: PDF.js extraction happens in browser to avoid Node.js compatibility issues
   */
  generateTOC: protectedProcedure
    .input(generateTOCInput)
    .mutation(async ({ ctx, input }) => {
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Check if flipbook exists and user has permission
      const flipbook = await prisma.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to modify this flipbook",
        });
      }

      // Validate structure of provided TOC data
      const validation = validateTOCStructure(input.tocData);
      if (!validation.valid) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: `Invalid TOC structure: ${validation.errors.join(", ")}`,
        });
      }

      // Save to database
      const updated = await prisma.flipbooks.update({
        where: { id: input.flipbookId },
        data: {
          toc_data: input.tocData as any,
          toc_auto_generated: true,
          toc_last_updated: new Date(),
        },
        select: {
          id: true,
          toc_data: true,
          toc_auto_generated: true,
          toc_last_updated: true,
        },
      });

      return {
        success: true,
        tocData: updated.toc_data as unknown as TOCData,
        itemCount: input.itemCount,
        warnings: input.warnings,
      };
    }),

  /**
   * Get TOC for a flipbook
   */
  getTOC: protectedProcedure
    .input(getTOCInput)
    .query(async ({ ctx, input }) => {
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Check if flipbook exists and user has permission
      const flipbook = await prisma.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
          toc_data: true,
          toc_auto_generated: true,
          toc_last_updated: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view this flipbook",
        });
      }

      // Return TOC data or empty structure if none exists
      return {
        tocData: (flipbook.toc_data as unknown as TOCData) || createEmptyTOC(),
        autoGenerated: flipbook.toc_auto_generated || false,
        lastUpdated: flipbook.toc_last_updated?.toISOString() || null,
      };
    }),

  /**
   * Update TOC manually
   * Allows full CRUD operations on TOC structure
   */
  updateTOC: protectedProcedure
    .input(updateTOCInput)
    .mutation(async ({ ctx, input }) => {
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Check if flipbook exists and user has permission
      const flipbook = await prisma.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to modify this flipbook",
        });
      }

      // Validate TOC structure
      const validation = validateTOCStructure(input.tocData);
      if (!validation.valid) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: `Invalid TOC structure: ${validation.errors.join(", ")}`,
        });
      }

      // Update last modified timestamp
      const tocData: TOCData = {
        ...input.tocData,
        lastModified: new Date().toISOString(),
      };

      // Save to database
      const updated = await prisma.flipbooks.update({
        where: { id: input.flipbookId },
        data: {
          toc_data: tocData as any,
          toc_auto_generated: false, // Manual update marks as not auto-generated
          toc_last_updated: new Date(),
        },
        select: {
          id: true,
          toc_data: true,
          toc_auto_generated: true,
          toc_last_updated: true,
        },
      });

      return {
        success: true,
        tocData: updated.toc_data as unknown as TOCData,
        lastUpdated: updated.toc_last_updated?.toISOString(),
      };
    }),

  /**
   * Delete TOC from flipbook
   */
  deleteTOC: protectedProcedure
    .input(deleteTOCInput)
    .mutation(async ({ ctx, input }) => {
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Check if flipbook exists and user has permission
      const flipbook = await prisma.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to modify this flipbook",
        });
      }

      // Clear TOC data
      await prisma.flipbooks.update({
        where: { id: input.flipbookId },
        data: {
          toc_data: null as any,
          toc_auto_generated: false,
          toc_last_updated: null,
        },
      });

      return { success: true };
    }),

  /**
   * Import TOC from CSV
   */
  importTOCFromCSV: protectedProcedure
    .input(importTOCInput)
    .mutation(async ({ ctx, input }) => {
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Check if flipbook exists and user has permission
      const flipbook = await prisma.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to modify this flipbook",
        });
      }

      // Parse CSV
      let tocData: TOCData;
      try {
        tocData = importTOCFromCSV(input.csv);
      } catch (error) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Invalid CSV format",
        });
      }

      // Validate structure
      const validation = validateTOCStructure(tocData);
      if (!validation.valid) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: `Invalid TOC structure: ${validation.errors.join(", ")}`,
        });
      }

      // Save to database
      const updated = await prisma.flipbooks.update({
        where: { id: input.flipbookId },
        data: {
          toc_data: tocData as any,
          toc_auto_generated: false,
          toc_last_updated: new Date(),
        },
        select: {
          id: true,
          toc_data: true,
          toc_last_updated: true,
        },
      });

      return {
        success: true,
        tocData: updated.toc_data as unknown as TOCData,
        itemCount: tocData.items.length,
      };
    }),

  /**
   * Export TOC to CSV
   */
  exportTOCToCSV: protectedProcedure
    .input(exportTOCInput)
    .query(async ({ ctx, input }) => {
      if (!features.flipbooks) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Flipbooks feature is not enabled",
        });
      }

      // Check if flipbook exists and user has permission
      const flipbook = await prisma.flipbooks.findUnique({
        where: { id: input.flipbookId },
        select: {
          id: true,
          created_by_id: true,
          toc_data: true,
        },
      });

      if (!flipbook) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Flipbook not found",
        });
      }

      if (flipbook.created_by_id !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "You do not have permission to view this flipbook",
        });
      }

      if (!flipbook.toc_data) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Flipbook does not have a TOC",
        });
      }

      // Export to CSV
      const csv = exportTOCToCSV(flipbook.toc_data as unknown as TOCData);

      return {
        csv,
        filename: `flipbook-${input.flipbookId}-toc.csv`,
      };
    }),
});
